/* -*- Mode: Pike; indent-tabs-mode: t; c-basic-offset: 2; tab-width: 8 -*- */
//! @b{Glade module@}
//!
//! Generates a Pike stub from a Glade file.
//!
//! Copyright © 2010, Pontus Östlund - @url{http://www.poppa.se@}
//!
//! @pre{@b{License GNU GPL version 3@}
//!
//! Glade.pmod is free software: you can redistribute it and/or modify
//! it under the terms of the GNU General Public License as published by
//! the Free Software Foundation, either version 3 of the License, or
//! (at your option) any later version.
//!
//! Glade.pmod is distributed in the hope that it will be useful,
//! but WITHOUT ANY WARRANTY; without even the implied warranty of
//! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//! GNU General Public License for more details.
//!
//! You should have received a copy of the GNU General Public License
//! along with Glade.pmod. If not, see <@url{http://www.gnu.org/licenses/@}>.
//! @}

import Parser.XML.Tree;

#define IS_ELEMENT(N)  (N)->get_node_type() == XML_ELEMENT
#define ATTR(N)        (N)->get_attributes()
#define VALUE(N)       (N)->value_of_node()
#define NAME(N)        (N)->get_tag_name()
#define KIDS(N)        (N)->get_children()

#define COLLECT(NAME, FUNC) _signals[NAME] = lambda (Node n) { (FUNC); }

#define THIS_NAME sprintf("%O", object_program(this))-"/main()->"
#define TRIM(S) String.trim_all_whites((S))

int(0..1) enable_gettext = 0;

class File
{
  string glade_file;
  array(GAny) objects = ({});
  string main_class;

  void create(string _glade_file)
  {
    glade_file = _glade_file;
    Node interface;
    Node root = parse_file(_glade_file);
    multiset(string) ifaces = (< "glade-interface" >);

    if (root) {
      foreach (KIDS(root), Node n) {
	if ( IS_ELEMENT(n) && ifaces[NAME(n)] ) {
	  interface = n;
	  break;
	}
      }
    }

    if (interface) {
      foreach (KIDS(interface), Node cn) {
      	if (IS_ELEMENT(cn)) {
      	  switch (NAME(cn))
      	  {
      	    // LibGlade
      	    case "widget":
	      objects += ({ GObject(cn) });
	      break;
      	  }
      	}
      }
    }
  }
  
  void generate(string filename)
  {
    string buffer = FILE;

#define STUB(X...) add_stub(sprintf(X) + "\n")
#define CONS(X...) add_cons(sprintf(X) + "\n")
    
    main:foreach(objects, GObject obj)
    {
      string data = "";
      string klass = CLASS;
      string window_id;
      array(string) defines = ({});
      array(string) members = ({});
      array(Signal) signals = ({});

      foreach (low_get_objects(obj)||({}), GObject o) {
	if (!window_id)
	  window_id = o->id;

	defines += ({ sprintf("protected Gtk.Widget %s;", o->id) });
	members += ({ sprintf("%-20s = WIDGET(%O);", o->id, o->id) });

	foreach (o->signals; string handler; string method)
	  signals += ({ Signal(handler, method) });
      }

      if (!window_id) {
	error("Found no top level widget!\n");
	return;
      }

      data += sprintf(klass, window_id, glade_file);
      data = replace(data, "[MEMBER-DEFINES]", defines*"\n  ");
      data = replace(data, "[MEMBERS]", members*"\n    ");
      data = replace(data, "[SIGNALS]", "([ " + (TRIM(signals->to_mapping()*",\n                               ")) + " ])");
      data = replace(data, "[SIGNAL-METHODS]", TRIM(signals->get_method_def()*"\n"));

      buffer += data;

      window_id = 0;
    }

    Stdio.write_file(filename, TRIM(buffer));
  }

  array(GObject) get_objects()
  {
    array(GObject) o;
    foreach (objects, GObject obj)
      o = low_get_objects(obj);

    return o;
  }

  private array(GObject) low_get_objects(GObject o)
  {
    array all = ({ o });
    foreach (o->children, GChild child) {
      if (child->gobject)
	all += low_get_objects(child->gobject);
    }

    return all;
  }

  private array(GChild) get_children(GObject o)
  {
    array all = ({});
    foreach (o->children, GChild child) {
      if (child->gobject) {
      	all += ({ child });
      	all += get_children(child->gobject);
      }
      else {
      	werror("%O has no gobject\n", child->packing);
      }
    }

    return all;
  }
}

class Signal(string handler, string method)
{
  string to_mapping()
  {
    return sprintf("%O : %[0]s", method);
  }

  string get_method_def()
  {
    string r = "  protected void %s()\n"
               "  {\n"
               "    werror(\"\\\"%[0]s\\\" not implemented!\\n\");\n"
               "  }\n";
    return sprintf(r, method);
  }
}

string FILE = #"
/*! DO NOT EDIT THIS FILE
 *!
 *! This file is auto generated by glade2pike. Make a separate
 *! file and create a class that inherits this one.
 *!
 *! This file was generated " + Calendar.now()->format_ext_time() + #"
 */

#define Gtk GTK2
#define WIDGET(N) gui->get_widget((N))
";

string CLASS = #"
public class %s
{
  protected Gtk.GladeXML gui;

  [MEMBER-DEFINES]

  void create()
  {
    gui = Gtk.GladeXML("+"\"%s\""+#", 0, %[0]O);

    [MEMBERS]

    gui->signal_autoconnect([SIGNALS], 0);
  }

  void show_all()
  {
    %[0]s->show_all();
  }

  int run() 
  {
    return %[0]s->run();
  }

  [SIGNAL-METHODS]
}
";

class GAny // {{{
{
  protected mapping(string:function) _signals = ([]);

  void create(Node n)
  {
    foreach (n->get_children(), Node cn) {
      if (IS_ELEMENT(cn)) {
      	if ( function f = _signals[NAME(cn)] )
      	  call_function(f, cn);
      }
    }
  }
} // }}}

class GPropertized // {{{
{
  inherit GAny;
  
  mapping(string:GProperty) properties = ([]);
  
  void create(Node n)
  {
    COLLECT("property", properties[ATTR(n)->name] = GProperty(n));
    ::create(n);
  }
} // }}}

class GProperty // {{{
{
  inherit GAny;
  
  constant ENUM_TYPE_MAP = ([
    "orientation"     : "G.ORIENTATION",
    "shadow_type"     : "G.SHADOW_TYPE",
    "window_position" : "G.WINDOW_POSITION",
    "type_hint"       : "Gdk.WindowTypeHint",
    "layout_style"    : "ButtonBoxStyle",
    "pack_type"       : "PackType"
  ]);

  constant SETTABLE = (<>);

  constant STRING = (<
    "version"
  >);

  string    name;
  string    value;
  int(0..1) translatable;

  void create(Node n)
  {
    name = ATTR(n)->name;
    value = VALUE(n);
    translatable = ATTR(n)->translatable == "yes";
  }
  
  string get_value()
  {
    if (value == "True")
      return "1";

    if (value == "False")
      return "0";

    if (name == "invisible_char")
      return string_to_utf8(sprintf("'%s'", value));

    if ( STRING[name] )
      return sprintf("\"%s\"", value);

    if ( value == "0" || (float)value > 0 || ENUM_TYPE_MAP[name] )
      return sprintf("%s", value);

    return sprintf("\"%s\"", string_to_utf8(value||""));
  }

  mixed cast(string how)
  {
    if (how == "string") {
      string r = name;
      string v = get_value();

      if (enable_gettext && translatable)
      	v = "_(" + v + ")";

      if ( string e = ENUM_TYPE_MAP[name] )
      	v = e + "_" + upper_case(replace(v, "-", "_"));

      if ( !SETTABLE[name] )
      	r = "set_" + name + "(" + v + ")";
      else
      	r += " = " + v;

      return r;
    }

    error("Can't cast %O() to %O", object_program(this), how);
  }
} // }}}

class GPacking // {{{
{
  inherit GPropertized;
  
  void create(Node n)
  {
    ::create(n);
  }
  
  string get_property(string index)
  {
    if ( GProperty prop = properties[index] )
      return prop->get_value();
    
    return 0;
  }
  
  string get_pack_type()
  {
    return properties->pack_type && properties->pack_type->get_value()||"start";
  }
  
  string get_pack_args()
  {
    string r = ", ";
    r += properties->expand && properties->expand->get_value()||"true";
    r += ", ";
    r += properties->fill && properties->fill->get_value()||"true";
    r += ", ";
    r += properties->padding && properties->padding->get_value()||"0";
    return r;
  }
} // }}}

class GChild // {{{
{
  inherit GAny;

  GObject gobject;
  GAny parent;
  GPacking packing;
  string type;

  void create(Node n, GAny _parent)
  {
    // GtkBuilder
    COLLECT("object",  gobject = GObject(n));
    // LibGlade
    COLLECT("widget",  gobject = GObject(n));
    COLLECT("packing", packing = GPacking(n));

    type = ATTR(n)->type;
    parent = _parent;
   ::create(n);
  }

  string _sprintf(int t)
  {
    return sprintf("%O(%O,%O)", object_program(this), 
                   gobject, packing && packing->properties);
  }
} // }}}

string remap_object_name(string name)
{
  name -= "Gtk";
  return ([ "VBox" : "Vbox",
            "HBox" : "Hbox" ])[name]||name;
}

class GObject // {{{
{
  inherit GPropertized;

  string class_name;
  string id;
  array(GChild) children = ({});
  mapping(string:string) signals = ([]);

  void create(Node n)
  {
    class_name = remap_object_name( ATTR(n)["class"] );
    id = replace(ATTR(n)["id"]||"", "-", "_");

    COLLECT("child",  children += ({ GChild(n, this) }));
    COLLECT("signal", signals[ATTR(n)->name] = ATTR(n)->handler); 

    ::create(n);
  }

  GProperty get_property(string index)
  {
    return properties[index];
  }
  
  array(string) to_init(void|int(0..1) is_root)
  {
    array(string) s = ({});
    string p = "";
    if (!is_root) {
      s = ({ id + " = G." + class_name + "()" });
      p = id + "->";
    }

    foreach (values(properties), GProperty prop)
      s += ({ p + prop->cast("string") });

    return s;
  }
  
  string _sprintf(int t)
  {
    return sprintf("%s::%s(%O)", THIS_NAME, class_name, id);
  }
} // }}}