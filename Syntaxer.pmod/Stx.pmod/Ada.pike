//| Generated by stxparser
//|
//| Inherit main class. If you'r creating a tag based syntax file inherit
//| HTML in Markup.pmod instead.
inherit "../Parser.pike";

//! The name of the language
public string title = "Ada";

//! Is the language case sensitive or not?
//!
//! @appears case_sensitive
protected int(0..1) _case_sensitive = 0;

//! Is the language HTML embedded or not?
//!
//! @appears html_embedded
public int(0..1) _html_embedded = 0;

//! Escape char of the language. Like backslash for most C-like languages.
//!
//! @appears escape
protected string _escape = "";

//! Delimiters like (, ), ; and so on
//!
//! @appears delimiters
protected multiset(string) _delimiters = (< "&","'","(",")","*","+",",","\226",".","/",":",";","<","=",">","|" >);

//! Array of chars defining strings
//!
//! @appears quotes
protected array(string) _quotes = ({ "'","\"" });

//! What's a line comment. Like for PHP: ({ "//", "#" })
//!
//! @appears linecomment
protected array(string) _linecomments = ({ "#","--" });

//! The colors mapping defines how things should be colorized. Each index should
//! correspond to either the name of a base class variable containing some syntax
//! information - like "blockcomments" for instance - or an index in the
//! "keywords" mapping. The value should be a hexadecimal color definition.
//!
//! An example:
//!
//!   colors = ([
//!     "blockcomment"       : "#aaa",
//!     "linecomment"        : "#aaa",
//!     "delimiter"          : "#00c"
//!     "built-in-functions" : "#900"
//!   ]);
//!
//! There are a few generic indexes that are being used:
//!
//!   1. default:      For text that's not matching any rules
//!   2. delimiter:    For language delimiters.
//!   3. quote:        For strings
//!   4. numeric:      For numbers
//!   5. linecomment:  For line comments
//!   6. blockcomment: For block comments
//!   7. preprocessor: For preprocessor instructions (like <?php ?>)
//!   8. macro:        For macro directives like C's #define MACRO
//!
//! @appears colors
protected mapping(string:string) _colors = ([
  "default"      : "#000",
  "delimiter"    : "#00C",
  "quote"        : "#070",
  "numeric"      : "purple",
  "linecomment"  : "#818A9E",
  "blockcomment" : "#818A9E",
  "preprocessor" : "lime",
  "macro"        : "#99510a",

  //| NOTE!!! The ones below is auto generated. Check that they correspond to
  //| the indices in "_keywords". And you might want to change the colors!
  "keyword-4"                 : "#8a0e0e",
  "keyword-3"                 : "#049a04",
  "keyword-2"                 : "#0000aa",
  "keyword-1"                 : "#0d0dba"
]);

//! Definitions for stuff that you want to add extra HTML around.
//! An example:
//!
//!   styles = ([
//!      "keywords"     : ({ "<b>", "</b>" }),
//!      "preprocessor" : ({ "<b style='background: black;'>", "</b>" }),
//!      "macro"        : ({ "<b>", "</b>" })
//!   ]);
//!
//! The indices works in the same way as for colors.
//!
//! @appears styles
protected mapping(string:array(string)) _styles = ([
  "keyword-1" : ({ "<b>", "</b>" }),
  "keyword-2" : ({ "<b>", "</b>" }),
  "keyword-3" : ({ "<b>", "</b>" }),
  "keyword-4" : ({ "<b>", "</b>" }),
  "prefix"    : ({ "<b>", "</b>" })
]);

//! Some languages like PHP, Perl, Ruby has some variable prefixes
//! like $, @, % so we can use them to highlight these variables
//! differently. The key should be an identifier to lookup in the
//! colors mapping and the value should be the actual prefix.
//! It could look like this for Perl:
//!
//!   prefixes = ([
//!     "prefix1" : "$",
//!     "prefix2" : "%",
//!     "prefix3" : "@"
//!   ])
//!
//! or if you want all prefixes to be colorized the same way
//!
//!   prefixes = ([
//!     "prefix" : ({ "$", "%", "@" })
//!   ]);
//!
//! @appears prefixes
protected mapping(string:string|array) _prefixes = ([ "prefix" : ({ ":","@","%","/" }) ]);

//! Definition of blockcomments. This should be an array if arrays where the
//! second array should contain two values: The first the pattern that starts
//! a block comment and the second the pattern that ends it.
//! Example: ({ ({ "/*", "*/" }) })
//!
//! @appears blockcomments
protected array(array(string)) _blockcomments = ({  });

//! HTML embedded languages use preprocessor instructions to tell when
//! the actual program code starts and ends. Add them here...
//! PHP would look like this:
//! ({
//!   ({ "<?php", "?>" }),
//!   ({ "<?", "?>" })
//! })
//!
//! @appears preprocs
protected array(array(string)) _preprocs = ({  });

/*******************************************************************************
 *                                                                             *
 *    NOTE! Uncomment the following variables if the language supports         *
 *    preprocessing macros. Otherwise the default values will apply.           *
 *                                                                             *
 ******************************************************************************/

//! For languages that has preprocessing macros
// protected int(0..1) macro = 1;

//! Can the macro start off of the first char. C# allows for this
// protected int(0..1) macro_indent = 0;

//! Default macro character
// protected string macro_char = "#";

//! Language keywords
//!
//! @appears keywords
protected mapping(string:multiset(string)) _keywords = ([
  "keyword-4" : (<
    "constraint_error","data_error","device_error","end_error",
    "layout_error","mode_error","name_error","numeric_error","program_error",
    "status_error","storage_error","tasking_error","use_error" >),

  "keyword-3" : (<
    "arithmetic","ascii","assertions","boolean","character",
    "complex_arrays","complex_io","directories","doubly_linked_lists",
    "duration","edf","environment_variables","false","float","formatting",
    "generic_complex_arrays","generic_real_arrays","group_budgets",
    "hashed_maps","hashed_sets","indefinite_doubly_linked_lists",
    "indefinite_hashed_maps","indefinite_hashed_sets",
    "indefinite_ordered_maps","indefinite_ordered_sets","indefinite_vectors",
    "integer","long_float","long_long_float","natural","ordered_maps",
    "ordered_sets","positive","real_arrays","round_robin","string",
    "task_termination","time_zones","timers","timing_events","true",
    "unbounded_io","vectors","wide_character","wide_string" >),

  "keyword-2" : (<
    "all_calls_remote","assert","assertion_policy","asynchronousatomic",
    "atomic_components","attach_handler","controlled","convention",
    "detect_blocking","elaborate","elaborate_all","elaborate_body","export",
    "import","inline","inspection_point","interrupt_handler",
    "interrupt_priority","license","linker_options","list","locking_policy",
    "no_return","normalize_scalars","optimize","pack","page","piority",
    "preelaborable_initialization","preelaborate",
    "priority_specific_dispatching","profile","pure","pure_function",
    "queueing_policy","remote_call_interface","remote_types","restrictions",
    "reviewable","shared_passive","storage_size","task_dispatching",
    "unchecked_union","unreferenced","unsuppress","volatile",
    "volatile_components" >),

  "keyword-1" : (<
    "abort","abs","abstract","accept","access","address","adjacent",
    "aft","aliased","alignment","all","and","array","at","base","begin",
    "bit_order","body","body_version","callable","caller","case","ceiling",
    "class","component_size","compose","constant","constrained","copy_sign",
    "count","declare","definite","delay","delta","denorm","digits","do",
    "else","elsif","end","entry","exception","exit","exponent",
    "external_tag","first","first_bit","floor","for","fore","fraction",
    "function","generic","goto","identity","if","image","in","input",
    "interface","is","last","last_bit","leading_part","length","limited",
    "loop","machine","machine_emax","machine_emin","machine_mantissa",
    "machine_overflow","machine_radix","machine_rounding","machine_rounds",
    "max","max_size_in_storage_elements","min","mod","model","model_emin",
    "model_epsilon","model_manitssa","model_small","modulus","new","not",
    "null","of","or","others","out","output","overriding","package",
    "partition_id","pos","position","pragma","pred","priority","private",
    "procedure","protected","raise","range","read","record","rem",
    "remainder","renames","requeue","return","reverse","round","rounding",
    "safe_first","safe_last","scale","scaling","select","separate",
    "signed_zeros","size","small","storage_pool","storage_size","subtype",
    "succ","synchronized","tag","tagged","task","terminate","terminated",
    "then","truncation","type","unbiased_rounding","unchecked_access",
    "until","use","val","valid","value","version","when","while",
    "wide_image","wide_value","wide_wide_image","wide_wide_value",
    "wide_wide_width","wide_width","width","with","write","xor" >)
]);

//! Constructor
//!
//! If you don't want to override one or more variables just comment them out
//! or remove them. If you wan't to add to the default variables just add a +
//! in front of =.
void create()
{
  linecomments   = _linecomments;
  delimiters     = _delimiters;
  blockcomments  = _blockcomments;
  prefixes       = _prefixes;
  colors         = _colors;
  styles         = _styles;
  preprocs       = _preprocs;
  html_embedded  = _html_embedded;
  case_sensitive = _case_sensitive;
  escape         = _escape;
  quotes         = _quotes;
  keywords       = _keywords;

  ::create();
}